## 1. Instalacion y Creacion del Proyecto

1. Cambiar de directorio en conda

```bash
D:
```

2. Ambiente virtual

```bash
conda create -n django01 python=3.9 # django01 es el nombre del venv
conda activate django01 # activar
conda deactivate django01 # desactivar
```

3. Instalar Django

```bash
pip install django
```

4. Iniciar proyecto

```bash
# Asegurarse estar en el cd deseado
django-admin startproject mysite
# Ruta:
```

5. Correr server.

```bash
python manage.py runserver
```

6. Iniciar Aplicacion _Polls_.

```bash
python manage.py startapp polls
```

## 2. Archivos:

### mysite/settings.py

```python
# Asegurar que la aplicacion este dentro del archivo setting Root

INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    ]
```

### polls/models.py

```python
# Se crea la base SQL

from django.db import models

# Cada clase es una tabla
class Question(models.Model):
    # Cada variable es un campo
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")

    # Para que al llamar la funcion regrese el contenido, no el objeto
    def __str__(self):
        return self.question_text

    # 1ra Version: Un metodo (campo) interno
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

    # 2da Version: correccion bug de publicaciones futuras
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    # Para que al llamar la función regrese el contenido, no el objeto
    def __str__(self):
        return self.choice_text
```

Para actualizar la base SQL utilizar los siguientes comandos:

```bash
# Decirle a DJANGO que modificamos los modelos
python manage.py makemigrations polls
# Para ver el SQL de la migracion 0001
python manage.py sqlmigrate polls 0001
# Crear los modelos en la DB
python manage.py migrate
```

### polls/views.py

```python
from django.http import HttpResponse
from django.http import HttpResponseRedirect
from django.http import Http404

from django.template import loader

from .models import *
from .models import Choice, Question

from django.shortcuts import render # con el paquete render, HttpResponse y loader no son necesarios de importar
from django.shortcuts import get_object_or_404

from django.urls import reverse

from django.views import generic

from django.utils import timezone

###########
# Index
###########

# 1er Version Index
    # Simple HttpResponse con texto
def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")

# 2do Version Index
    # 1) Listado de modelos
    # 2) Load template
    # 3) Fill context
    # 4) return an HttpResponse
def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    template = loader.get_template("polls/index.html")
    context = {"latest_question_list": latest_question_list}
    return HttpResponse(template.render(context, request))

# 3er Version Index:
    # 1) Listado de modelos
    # 2) fill a context,
    # 3) render with the template
def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    context = {"latest_question_list": latest_question_list}
    # render(request, template, dictionary)
    return render(request, "polls/index.html", context)

# 4ta Version Index: Genreic View
    # Generic view requires a model to act upon
class IndexView(generic.ListView):
    # ListView generic view uses a default template called <app name>/<model name>_list.html
    # template_name to use a particular template instead of the autogenerated default template name
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"

    # No Model was provided
    # Instead, a list of items is given
    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by("-pub_date")[:5]

# 5ta Version: Mejorar el get_queryset
class IndexView(generic.ListView):
    def get_queryset(self):
        """
        Return the last five published questions (not including those set to be
        published in the future).
        """
        # __lte = Less Than or Equal
        return Question.objects.filter(pub_date__lte=timezone.now()).order_by("-pub_date")[:5]

###########
# Detail:
###########

# 1. Version Error 404
    # raise Http404
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, "polls/detail.html", {"question": question})

# 2. Version Error 404
    # get_object_or_404
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, "polls/detail.html", {"question": question})

# 3ra Version Generic View
class DetailView(generic.DetailView):
    # Model atribute
    model = Question
    # DetailView generic view uses a template called <app name>/<model name>_detail.html
    # template_name to use a particular template instead of the autogenerated default template name
    template_name = "polls/detail.html"

# 4ta Version Generic View
class DetailView(generic.DetailView):

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())

###########
# Results
###########

# 1. Version
def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)

# 2. Version
def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, "polls/results.html", {"question": question})

# 3ra Version: Generic View
class ResultsView(generic.DetailView):
    # Model atribute
    model = Question
    template_name = "polls/results.html"

###########
# Vote
###########

# 1. Version
def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)

# 2. Version
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        # request.POST es un diccionario que devuelve strings
        selected_choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message": "You didn't select a choice.",
            },
        )
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing with POST data.
	    # This prevents data from being posted twice if a user hits the Back button.
        # reverse funciona igual que la tag "url"
        return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))

```

### Polls/urls.py

```python
# Se agregan las urls que hacen referencia a las vistas creadas

from django.urls import path
from . import views

# NameSpacing URL
app_name = "polls"

##########
# 1ra version
##########

urlpatterns = [
    # /polls/
    path("", views.index, name="index"),
    # /polls/5/
    path("<int:question_id>/", views.detail, name="detail"),
    # /polls/5/results/
    path("<int:question_id>/results/", views.results, name="results"),
    # /polls/5/vote/
    path("<int:question_id>/vote/", views.vote, name="vote"),
]

##########
# 2da version: Adaptada a Generic Views
##########

urlpatterns = [
    # /polls/
    path("", views.IndexView.as_view(), name="index"),
    # /polls/5/
    path("<int:pk>/", views.DetailView.as_view(), name="detail"),
    # /polls/5/results/
    path("<int:pk>/results/", views.ResultsView.as_view(), name="results"),
    # /polls/5/vote/
    path("<int:question_id>/vote/", views.vote, name="vote"),
]

```

### mysite/urls.py

```python
# Asegurar que que el Root tenga acceso a las url´s de la aplicacion en especifico

from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path("polls/", include("polls.urls")),
    path("admin/", admin.site.urls),
]
```

### polls/templates/polls/---.html

```django
{# Se crean los Templates utilizados en las vistas #}

{#
##########
# INDEX
##########
#}

{% if latest_question_list %}
<ul>
  {% for question in latest_question_list %}
  <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
  {% endfor %}
</ul>
{% else %}
<p>No polls are available.</p>
{% endif %}


{#
##########
# DETAIL
##########
#}

{# OLD #}
<h1>{{ question.question_text }}</h1>
<ul>
  {% for choice in question.choice_set.all %}
  <li>{{ choice.choice_text }}</li>
  {% endfor %}
</ul>



{# NEW: Implementa un form #}

{# el metodo POST modifica la informacion en el servidor, a diferencia de GET #}
<form action="{% url 'polls:vote' question.id %}" method="post">

{# csrf sirve para prevenir ataques de Cross Site Request Forgeries #}
{% csrf_token %}

<fieldset>
    <legend><h1>{{ question.question_text }}</h1></legend>

    {# imprime un mensaje error si se proporciona la variable error_message #}
    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

    {% for choice in question.choice_set.all %}
        {# el boton radio es el que solo permite seleccionar una opcion #}
        {# forloop.counter indica cuantas veces el for ha realizado el loop #}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
        <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
    {% endfor %}

</fieldset>

{# este el el nombre del boton submit #}
<input type="submit" value="Vote">
</form>

{#
##########
# RESULTS
##########
#}

<h1>{{ question.question_text }}</h1>

<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote again?</a>


```

### polls/admin.py

```python
# Agregar un menu en el administrador para el modelo

from django.contrib import admin
from .models import Question
admin.site.register(Question)
```

Se necesita crear un superuser

```bash
python manage.py createsuperuser
# user: rafa
# mail: rafa@rafa.com
# psw: 12345
```

## 3. Shell:

Para ingresar datos dentro de los modelos (bases de datos):

1. **Ingresar al shell**

```bash
python manage.py shell
```

2. **Importar insumos**

```python
from polls.models import Choice, Question  # Import the model classes we just wrote.
from django.utils import timezone
current_year = timezone.now().year
```

3. **Metodos**

- Crea objeto dentro de modelo.

```python
q = Question(question_text="What's new?", pub_date=timezone.now())
```

- Guardar

```python
q.save()
```

- Llamar a los objetos

```python
Question.objects.all()
# Respuesta:
#    <QuerySet [<Question: Question object (1)>]>

# Respuesta con la funcion de str dentro del modelo:
#   <QuerySet [<Question: What's up?>]>
```

- Llamar a los objetos del modelo complementario

```python
q.choice_set.all()
```

- Filtrar para obtener **multiples** objetos

```python
Question.objects.filter(id=1)
Question.objects.filter(question_text\_\_startswith="What")
Choice.objects.filter(question**pub_date\_\_year=current_year)
```

- Filtrar para obtener un **unico objeto**, devuelve un error si no encuentra alguno o encuentra muchos

```python
Question.objects.get(id=1)
Question.objects.get(pk=1)
Question.objects.get(pub_date**year=current_year)
```

- Borrar

```python
c = q.choice_set.filter(choice_text\_\_startswith="Just hacking")
c.delete()
```

4. **Atributos/Campos del modelo**

- ID (atributo interno)

```python
q.id
# Respuesta: 1
```

- Campo "question_text"

```python
q.question_text
# Respuesta: "What's new?"
```

- Campo "pub_date"

```python
q.pub_date
# Respuesta: datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)
```

- Cambiar valores de los atributos en el mismo shell donde fue creado (recordar guardar al finalizar)

```python
q.question_text = "What's up?"
```

- Cambiar valores de los atributos tras buscar el valor requerido (recordar guardar al finalizar)

Utilizando un GET

```python
q = Question.objects.get(pk=1)
q.question_text = 'some value'
q.save()
```

Utilizando un Filter y un Update

```python
Question.objects.filter(pk=1).update(question_text='some value')
```

- INSERT al modelo complementario que depende de Question

```python
q.choice_set.create(choice_text="Not much", votes=0)
q.choice_set.create(choice_text="The sky", votes=0)
c = q.choice_set.create(choice_text="Just hacking again", votes=0)
```

## 4. Templates:

Sus componentes son los siguientes:

1. Variables:
   - Surrounded by **{{** and **}}**.
   - Dot notation for lookup.
     - {{ my_dict.key }}
     - {{ my_object.attribute }}
     - {{ my_list.0 }}

```django
My first name is {{ first_name }}. My last name is {{ last_name }}.
{# RESULTADO: My first name is John. My last name is Doe.#}
```

2. Tags:

   - Surrounded by **{%** and **%}**.
   - Accept arguments.

```django
{% csrf_token %}

<p>Rendered text with {{ pub_date|date:"c" }}</p>
{% comment "Optional note" %}
    <p>Commented out text with {{ create_date|date:"c" }}</p>
{% endcomment %}
```

3. Filters:
   - Use pipe **"|"**
   - Transform values of variables and tags

```django
{'django': 'the web framework for perfectionists with deadlines'}
{{ django|title }}
{# RESPUESTA: The Web Framework For Perfectionists With Deadlines#}
```

4. Comments:
   - Surrounded by **{#** and **#}**.
   - Can also use the comment tag:

```django
1.
{# this won't be rendered #}

2.
{% comment "Optional note" %}
    <p>Commented out text with {{ create_date|date:"c" }}</p>
{% endcomment %}
```

## 5. URL Management

- To avoid hardcoded url, we use the tag **"url"**

```django
{# OLD: HARDCODED URL #}
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>

{# NEW: TAG URL #}
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
```

- Name spacing URLs
  - We add the variable "app_name" to the Polls/urls.py file to avoid mixup between apps.
  - And then Change the reference URL

```python
# Polls/urls.py
app_name = "polls"
```

```django
{# OLD #}
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>

{# NEW #}
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
```

## 6. Testing

We have Identified a bug in the POLLS aplication:

- Question.was_published_recently() method returns TRUE when the Question was published within the last day, but also if the field is in the future.

### Steps:

### 1. Confirm the bug in the shell

```bash
python manage.py shell
```

```python
import datetime
from django.utils import timezone
from polls.models import Question
# create a Question instance with pub_date 30 days in the future
future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
# Aply method to the new date: was it published recently?
future_question.was_published_recently()
# Returns: True
```

Future Publications are not recent.
This is a bug.

### 2. Create a test to expose the bug.

- Turn what we just made in the shell into an automatic test.
- Create the test in the file polls/test.py

```python
import datetime
from django.test import TestCase
from django.utils import timezone
from .models import Question

class QuestionModelTests(TestCase):
    # Test Method
    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        # Should return false
        # Raises an assertionError ir returns TRUE
        self.assertIs(future_question.was_published_recently(), False)
```

### 3. Run the test in the terminal

- manage.py test polls will look for test in the app
- It will create a database for testing
- It will look for TEST METHODS in the **subclass** of the class django.test.TestCase
  - The TEST METHODS is the **"def"** function
  - Its name should begin with **test** .
- Informs us which test failed.

```bash
python manage.py test polls

# Output:
"""
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question
    self.assertIs(future_question.was_published_recently(), False)
AssertionError: True is not False

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Destroying test database for alias 'default'...
"""
```

### 4. Fix the bug

- Fix the model in **models.py**
- Run again the test, it should return this:

```bash
"""
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
Destroying test database for alias 'default'...
"""
```

### 5. Add more tests.

```python

##################
# Test Index View
##################

def test_was_published_recently_with_old_question(self):
    """
    was_published_recently() returns False for questions whose pub_date
    is older than 1 day.
    """
    time = timezone.now() - datetime.timedelta(days=1, seconds=1)
    old_question = Question(pub_date=time)
    self.assertIs(old_question.was_published_recently(), False)


def test_was_published_recently_with_recent_question(self):
    """
    was_published_recently() returns True for questions whose pub_date
    is within the last day.
    """
    time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
    recent_question = Question(pub_date=time)
    self.assertIs(recent_question.was_published_recently(), True)

from django.urls import reverse

# function to create questions
def create_question(question_text, days):
    """
    Create a question with the given `question_text` and published the
    given number of `days` offset to now (negative for questions published
    in the past, positive for questions that have yet to be published).
    """
    time = timezone.now() + datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date=time)


class QuestionIndexViewTests(TestCase):
    def test_no_questions(self):
        """
        If no questions exist, an appropriate message is displayed.
        """
        response = self.client.get(reverse("polls:index"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "No polls are available.")
        self.assertQuerySetEqual(response.context["latest_question_list"], [])

    def test_past_question(self):
        """
        Questions with a pub_date in the past are displayed on the
        index page.
        """
        question = create_question(question_text="Past question.", days=-30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question],
        )

    def test_future_question(self):
        """
        Questions with a pub_date in the future aren't displayed on
        the index page.
        """
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertContains(response, "No polls are available.")
        self.assertQuerySetEqual(response.context["latest_question_list"], [])

    def test_future_question_and_past_question(self):
        """
        Even if both past and future questions exist, only past questions
        are displayed.
        """
        question = create_question(question_text="Past question.", days=-30)
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question],
        )

    def test_two_past_questions(self):
        """
        The questions index page may display multiple questions.
        """
        question1 = create_question(question_text="Past question 1.", days=-30)
        question2 = create_question(question_text="Past question 2.", days=-5)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question2, question1],
        )

##################
# Test Detail View
##################

class QuestionDetailViewTests(TestCase):
    def test_future_question(self):
        """
        The detail view of a question with a pub_date in the future
        returns a 404 not found.
        """
        future_question = create_question(question_text="Future question.", days=5)
        url = reverse("polls:detail", args=(future_question.id,))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_past_question(self):
        """
        The detail view of a question with a pub_date in the past
        displays the question's text.
        """
        past_question = create_question(question_text="Past Question.", days=-5)
        url = reverse("polls:detail", args=(past_question.id,))
        response = self.client.get(url)
        self.assertContains(response, past_question.question_text)

```

### Django Test Client

### Steps:

The test Client is used to simulate user interacting with the code at the view level.

### 1. Test the environment in the shell

```bash
python manage.py shell
```

The **setup_test_environment** installs a template renderer

```python
from django.test.utils import setup_test_environment
setup_test_environment()
```

### 2. Test client

Later on this import wont be necesary because **django.test.TestCase** has its own client.

```python
from django.test import Client
# create an instance of the client for our use
client = Client()
```

Ask the client to do some work:

```python
# get a response from '/'
response = client.get("/")
# Result: Not Found: /

response.status_code # we should expect a 404 from that address
# Result: 404

# We should expect to find something at '/polls/'
from django.urls import reverse
response = client.get(reverse("polls:index"))
response.status_code
# Result: 200

response.content
# Result: b'\n    <ul>\n    \n        <li><a href="/polls/1/">What&#x27;s up?</a></li>\n    \n    </ul>\n\n'

response.context["latest_question_list"]
# Result: <QuerySet [<Question: What's up?>]>
```

### Rules of tumb wen testing:

1. Separate TestClass for each model or view.
2. Separate test method for each set of conditions.
3. test method names that describe their function.

## 7. Static files

Create a directory calles "static" in the polls directory, then the directory "polls" inside, and then the style.css file.

### polls/static/polls/style.css

```css
li a {
  color: green;
}
```

Then add the css to the template.

```html
{% load static %}
<link rel="stylesheet" href="{% static 'polls/style.css' %}" />
```

Adding a background image to the css.
Add a directory in the app: **polls/static/polls/images/background.png**

```css
body {
  background: white url("images/background.png") no-repeat;
}
```

## 8. Admin form customization

In the admin.py file you put the default form representation of the model.

```python
from django.contrib import admin
from .models import Question

admin.site.register(Question)
```

We will change the code with:

```python
#############
# 2nd version
#############

class QuestionAdmin(admin.ModelAdmin):
    # Fields lets you determine the admin options for a model
    fields = ["pub_date", "question_text"]

admin.site.register(Question, QuestionAdmin)

#############
# 3rd version
#############

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        # (name: title of the fieldset, field_options: dict of finro)
        (None, {"fields": ["question_text"]}),
        ("Date information", {"fields": ["pub_date"]}),
    ]

admin.site.register(Question, QuestionAdmin)

#############
# 4rth version
#############

classes = ["collapse", "wide", "extrapretty"]

class ChoiceInline(admin.StackedInline):
    model = Choice
    # Provide fields for 3 choices
    extra = 3

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        # (name, field_options)
        (None, {
            "fields": ["question_text"]
            }),
        ("Date information", {
            "fields": ["pub_date"],
            "classes": classes
            }),
    ]
    # Objects of the model "Choice" are edited on the Question admin page
    inlines = [ChoiceInline]


admin.site.register(Question, QuestionAdmin)


#############
# 5th version
#############

# Para mostrar los datos en forma tabular
class ChoiceInline(admin.TabularInline):
    model = Choice
    # Provide fields for # choices
    extra = 1

class QuestionAdmin(admin.ModelAdmin):
    # ...

    # Which field are displayed con the change lsita page of admin, if not specified it will display a single columns with __str__()
    list_display = ["question_text", "pub_date", "was_published_recently"]
    # Add a Filter sidebar
    list_filter = ["pub_date"]

```

Pattern for admin forms:

1. Create a model admin class.
2. Pass the class as the 2nd argument in the **admin.site.register()**

Add templates to the admin page.

```python
# mysite/settings.py
# Make shure your  file has this:
TEMPLATES = [{"DIRS": [BASE_DIR / "templates"]}
```

```python
# \mysite\templates\admin\base_site.html
{% extends "admin/base.html" %}

{% block title %}{% if subtitle %}{{ subtitle }} | {% endif %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}

{% block branding %}
<div id="site-name"><a href="{% url 'admin:index' %}">{{ site_header|default:_('Django administration') }}</a></div>
{% if user.is_anonymous %}
  {% include "admin/color_theme_toggle.html" %}
{% endif %}
{% endblock %}

{% block nav-global %}{% endblock %}
```

## Final App Layout

mysite/
manage.py
mysite/
**init**.py
settings.py
urls.py
asgi.py
wsgi.py
polls/
**init**.py
admin.py
apps.py
migrations/
**init**.py
0001_initial.py
models.py
static/
polls/
images/
background.gif
style.css
templates/
polls/
detail.html
index.html
results.html
tests.py
urls.py
views.py
templates/
admin/
base_site.html
